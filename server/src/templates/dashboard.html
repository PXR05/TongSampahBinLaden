<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ESP32 Dashboard</title>
    <link rel="stylesheet" href="/static/style.css" />
  </head>
  <body>
    <div class="card card--narrow">
      <h1>ESP32 Dashboard</h1>
      <div class="row">
        <label for="deviceSelect">Device:</label
        ><select id="deviceSelect">
          <option value="">Select...</option>
        </select>
        <div class="muted ml-auto" id="lastUpdateSmall">Last update: --</div>
      </div>
      <div class="controls" id="controlsRow">
        <div class="controls-grid">
          <div class="control-group">
            <div class="control-title">Mode</div>
            <div class="control-row">
              <button
                class="btn"
                id="btnAuto"
                title="Return to auto (PIR) mode"
              >
                Auto
              </button>
              <button class="btn" id="btnOpen" title="Set to 90°">
                Open 90°
              </button>
              <button class="btn" id="btnClose" title="Set to 0°">
                Close 0°
              </button>
            </div>
          </div>
          <div class="control-group">
            <div class="control-title">Servo angle</div>
            <div class="control-row">
              <input
                type="range"
                id="angleSlider"
                min="0"
                max="180"
                value="90"
              />
              <span id="angleValue">90°</span>
            </div>
            <button class="btn" id="btnSendAngle">Send</button>
          </div>
          <div class="control-group">
            <div class="control-title">Alert threshold</div>
            <div class="control-row">
              <label for="thresholdInput" class="muted">Full ≤</label>
              <input
                id="thresholdInput"
                type="number"
                step="0.1"
                min="0"
                value="5"
              />
              <span class="muted">cm</span>
            </div>
            <div class="control-row mt8">
              <label for="emptyThresholdInput" class="muted">Empty ≥</label>
              <input
                id="emptyThresholdInput"
                type="number"
                step="0.1"
                min="0"
                value="15"
              />
              <span class="muted">cm</span>
            </div>
            <div class="control-row mt8">
              <label for="sustainInput" class="muted">for</label>
              <input
                id="sustainInput"
                type="number"
                step="0.5"
                min="0"
                value="3"
              />
              <span class="muted">seconds</span>
            </div>
            <button
              class="btn"
              id="btnSaveThreshold"
              title="Save alert threshold"
            >
              Save
            </button>
          </div>
        </div>
      </div>
      <div class="grid row mt16">
        <div class="stat">
          <div class="label">Distance</div>
          <div class="value" id="distance">-- cm</div>
        </div>
        <div class="stat">
          <div class="label">Motion</div>
          <div class="value" id="motion">--</div>
        </div>
        <div class="stat">
          <div class="label">Servo</div>
          <div class="value" id="servoPosition">--°</div>
        </div>
        <div class="stat">
          <div class="label">Status</div>
          <div class="value" id="fullStatus">--</div>
        </div>
      </div>
      <div class="mt16">
        <div class="sectionHeader">
          <div class="muted">Distance (last)</div>
          <a id="moreDistance" href="#" class="muted no-underline">More ›</a>
        </div>
        <canvas id="distanceChart" height="120"></canvas>
      </div>
      <div class="mt12">
        <div class="sectionHeader">
          <div class="muted">Servo (last)</div>
          <a id="moreServo" href="#" class="muted no-underline">More ›</a>
        </div>
        <canvas id="servoChart" height="100"></canvas>
      </div>
      <div class="mt12">
        <div class="sectionHeader">
          <div class="muted">Motion (last)</div>
          <a id="moreMotion" href="#" class="muted no-underline">More ›</a>
        </div>
        <canvas id="motionChart" height="80"></canvas>
      </div>
      <div class="muted" id="statusText">Waiting for data…</div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
      let selectedDevice = "",
        refreshHandle,
        distanceChart,
        servoChart,
        motionChart,
        els,
        distanceCtx,
        servoCtx,
        motionCtx;
      document.addEventListener("DOMContentLoaded", () => {
        const $ = (id) => document.getElementById(id);
        els = {
          deviceSelect: $("deviceSelect"),
          lastUpdateSmall: $("lastUpdateSmall"),
          distance: $("distance"),
          motion: $("motion"),
          servoPosition: $("servoPosition"),
          fullStatus: $("fullStatus"),
          statusText: $("statusText"),
          thresholdInput: $("thresholdInput"),
          emptyThresholdInput: $("emptyThresholdInput"),
          sustainInput: $("sustainInput"),
          angleSlider: $("angleSlider"),
          angleValue: $("angleValue"),
        };

        function calculateFillStatus(distance, threshold, emptyThreshold) {
          if (distance === null || distance === undefined) {
            return "Unknown";
          }

          const partialThreshold = threshold * 1.33;

          if (distance <= threshold) {
            return "Full";
          } else if (distance <= partialThreshold) {
            return "Partial";
          } else if (distance >= emptyThreshold) {
            return "Empty";
          } else {
            return "Partial";
          }
        }
        distanceCtx = $("distanceChart").getContext("2d");
        servoCtx = $("servoChart").getContext("2d");
        motionCtx = $("motionChart").getContext("2d");

        loadDevices();
        startAutoRefresh();
        els.deviceSelect?.addEventListener("change", (e) => {
          selectedDevice = e.target.value;
          updateDashboard();
          updateCharts();
        });

        const slider = els.angleSlider;
        const angleValue = els.angleValue;
        slider?.addEventListener("input", () => {
          angleValue.textContent = `${slider.value}°`;
        });
        document.getElementById("btnAuto")?.addEventListener("click", () => {
          sendCommand({ action: "auto" });
        });
        document.getElementById("btnOpen")?.addEventListener("click", () => {
          sendCommand({ action: "setAngle", targetPosition: 90 });
        });
        document.getElementById("btnClose")?.addEventListener("click", () => {
          sendCommand({ action: "setAngle", targetPosition: 0 });
        });
        document
          .getElementById("btnSendAngle")
          ?.addEventListener("click", () => {
            const v = parseInt(slider.value, 10);
            sendCommand({ action: "setAngle", targetPosition: v });
          });

        loadThreshold();
        document
          .getElementById("btnSaveThreshold")
          ?.addEventListener("click", async () => {
            const val = parseFloat(els.thresholdInput.value);
            const emptyVal = parseFloat(els.emptyThresholdInput.value);
            if (
              Number.isNaN(val) ||
              val < 0 ||
              Number.isNaN(emptyVal) ||
              emptyVal < 0
            )
              return;
            try {
              const res = await fetch("/api/settings", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  thresholdCm: val,
                  emptyThresholdCm: emptyVal,
                  alertSustainSec: parseFloat(els.sustainInput.value),
                }),
              });
              if (!res.ok) throw new Error("HTTP " + res.status);
              const j = await res.json();
              document.getElementById("statusText").textContent =
                `Alert: ≤ ${j.thresholdCm} cm, ≥ ${j.emptyThresholdCm} cm for ${j.alertSustainSec}s`;
            } catch (e) {
              els.statusText.textContent = "Failed to save threshold";
            }
          });

        const bindMore = (id) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.addEventListener("click", (e) => {
            e.preventDefault();
            const dev = selectedDevice || "";
            const url = dev
              ? `/history?deviceId=${encodeURIComponent(dev)}`
              : "/history";
            window.location.href = url;
          });
        };
        bindMore("moreDistance");
        bindMore("moreServo");
        bindMore("moreMotion");
      });

      async function sendCommand(cmd) {
        try {
          if (!selectedDevice) {
            const dd = await (await fetch("/api/device-data")).json();
            const ids = Object.keys(dd);
            if (!ids.length) {
              els.statusText.textContent = "No devices available for commands";
              return;
            }
            selectedDevice = ids[0];
          }

          const dd = await (await fetch("/api/device-data")).json();
          if (!dd[selectedDevice]) {
            els.statusText.textContent = `Cannot send command: ${selectedDevice} is offline`;
            return;
          }

          const body = { deviceId: selectedDevice, ...cmd };
          const res = await fetch("/api/command", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const j = await res.json();
          els.statusText.textContent =
            j.action === "auto"
              ? "Auto mode set"
              : `Command sent: ${j.targetPosition ?? "-"}°`;
        } catch (e) {
          console.error("sendCommand", e);
          els.statusText.textContent = "Failed to send command";
        }
      }
      async function loadDevices() {
        try {
          const e = await fetch("/api/device-data"),
            t = await e.json(),
            n = Object.keys(t),
            a = document.getElementById("deviceSelect");

          let allDevices = n;
          if (n.length === 0) {
            try {
              const devicesResponse = await fetch("/api/devices");
              const devicesData = await devicesResponse.json();
              allDevices = devicesData.deviceIds || [];
            } catch (err) {
              console.warn("Could not load historical devices", err);
            }
          }

          ((a.innerHTML =
            '<option value="">Select...</option>' +
            allDevices
              .map((e) => `<option value="${e}">${e}</option>`)
              .join("")),
            !selectedDevice &&
              allDevices.length &&
              ((selectedDevice = allDevices[0]), (a.value = selectedDevice)),
            updateDashboard());
        } catch (e) {
          console.error("loadDevices", e);
        }
      }
      async function updateDashboard() {
        try {
          const e = await fetch("/api/device-data"),
            t = await e.json(),
            n = selectedDevice ? t[selectedDevice] : t[Object.keys(t)[0]];
          if (!n) {
            if (selectedDevice) {
              await loadHistoricalDataForDevice(selectedDevice);
            } else {
              await loadMostRecentData();
            }
            return;
          }
          ((els.distance.textContent =
            null != n.distance
              ? `${Number(n.distance).toFixed(1)} cm`
              : "-- cm"),
            (els.motion.textContent = n.motion ? "Detected" : "None"),
            (els.servoPosition.textContent =
              null != n.servoPosition ? `${n.servoPosition}°` : "--°"),
            (els.fullStatus.textContent = n.fillStatus
              ? n.fillStatus.charAt(0).toUpperCase() + n.fillStatus.slice(1)
              : n.isFull
                ? "Full"
                : "Not full"),
            (els.fullStatus.style.color =
              n.fillStatus === "full" || n.isFull
                ? "#dc3545"
                : n.fillStatus === "partial"
                  ? "#fd7e14"
                  : n.fillStatus === "empty"
                    ? "#28a745"
                    : "#6c757d"),
            (els.lastUpdateSmall.textContent = `Last update: ${
              n.serverTimestamp
                ? new Date(n.serverTimestamp).toLocaleTimeString()
                : "--"
            }`),
            (els.statusText.textContent = "Connected"));
        } catch (e) {
          (console.error("updateDashboard", e),
            (els.statusText.textContent = "Error fetching data"));
        }
      }
      function setNoData() {
        ((els.distance.textContent = "-- cm"),
          (els.motion.textContent = "--"),
          (els.servoPosition.textContent = "--°"),
          (els.fullStatus.textContent = "--"),
          (els.fullStatus.style.color = "#6c757d"),
          (els.lastUpdateSmall.textContent = "Last update: --"),
          (els.statusText.textContent = "No devices sending data"));
      }

      async function loadMostRecentData() {
        try {
          const devicesResponse = await fetch("/api/devices");
          const devicesData = await devicesResponse.json();
          const deviceIds = devicesData.deviceIds;

          if (!deviceIds || deviceIds.length === 0) {
            return void setNoData();
          }

          const mostRecentDevice = deviceIds[0];

          const historyResponse = await fetch(
            `/api/history?deviceId=${encodeURIComponent(mostRecentDevice)}&limit=1`,
          );
          const historyData = await historyResponse.json();

          if (!historyData.timestamps || historyData.timestamps.length === 0) {
            return void setNoData();
          }

          const latestData = {
            distance: historyData.distance[0],
            motion: historyData.motion[0],
            servoPosition: historyData.servo[0],
            serverTimestamp: historyData.timestamps[0],
            fillStatus: historyData.fillStatus
              ? historyData.fillStatus[0]
              : null,
          };

          let isFull = false;
          let fillStatus = "Unknown";
          try {
            const settingsResponse = await fetch("/api/settings");
            const settings = await settingsResponse.json();
            if (
              latestData.distance !== null &&
              latestData.distance <= settings.thresholdCm
            ) {
              isFull = true;
            }
            if (!latestData.fillStatus) {
              fillStatus = calculateFillStatus(
                latestData.distance,
                settings.thresholdCm,
                settings.emptyThresholdCm,
              );
            } else {
              fillStatus = latestData.fillStatus;
            }
          } catch (e) {
            console.warn(
              "Could not load threshold settings for status calculation",
            );
          }

          latestData.isFull = isFull;
          latestData.fillStatus = fillStatus;

          ((els.distance.textContent =
            null != latestData.distance
              ? `${Number(latestData.distance).toFixed(1)} cm`
              : "-- cm"),
            (els.motion.textContent = latestData.motion ? "Detected" : "None"),
            (els.servoPosition.textContent =
              null != latestData.servoPosition
                ? `${latestData.servoPosition}°`
                : "--°"),
            (els.fullStatus.textContent =
              latestData.fillStatus ||
              (latestData.isFull ? "Full" : "Not full")),
            (els.fullStatus.style.color =
              latestData.fillStatus === "full" || latestData.isFull
                ? "#dc3545"
                : latestData.fillStatus === "partial"
                  ? "#fd7e14"
                  : latestData.fillStatus === "empty"
                    ? "#28a745"
                    : "#6c757d"),
            (els.lastUpdateSmall.textContent = `Last update: ${
              latestData.serverTimestamp
                ? new Date(latestData.serverTimestamp).toLocaleTimeString()
                : "--"
            } (Historical)`),
            (els.statusText.textContent = `Showing latest data from ${mostRecentDevice} (Offline)`));
        } catch (e) {
          console.error("loadMostRecentData", e);
          setNoData();
        }
      }

      async function loadHistoricalDataForDevice(deviceId) {
        try {
          const historyResponse = await fetch(
            `/api/history?deviceId=${encodeURIComponent(deviceId)}&limit=1`,
          );
          const historyData = await historyResponse.json();

          if (!historyData.timestamps || historyData.timestamps.length === 0) {
            return void setNoData();
          }

          const latestData = {
            distance: historyData.distance[0],
            motion: historyData.motion[0],
            servoPosition: historyData.servo[0],
            serverTimestamp: historyData.timestamps[0],
            fillStatus: historyData.fillStatus
              ? historyData.fillStatus[0]
              : null,
          };

          let isFull = false;
          let fillStatus = "Unknown";
          try {
            const settingsResponse = await fetch("/api/settings");
            const settings = await settingsResponse.json();
            if (
              latestData.distance !== null &&
              latestData.distance <= settings.thresholdCm
            ) {
              isFull = true;
            }
            if (!latestData.fillStatus) {
              fillStatus = calculateFillStatus(
                latestData.distance,
                settings.thresholdCm,
                settings.emptyThresholdCm,
              );
            } else {
              fillStatus = latestData.fillStatus;
            }
          } catch (e) {
            console.warn(
              "Could not load threshold settings for status calculation",
            );
          }

          latestData.isFull = isFull;
          latestData.fillStatus = fillStatus;

          ((els.distance.textContent =
            null != latestData.distance
              ? `${Number(latestData.distance).toFixed(1)} cm`
              : "-- cm"),
            (els.motion.textContent = latestData.motion ? "Detected" : "None"),
            (els.servoPosition.textContent =
              null != latestData.servoPosition
                ? `${latestData.servoPosition}°`
                : "--°"),
            (els.fullStatus.textContent =
              latestData.fillStatus ||
              (latestData.isFull ? "Full" : "Not full")),
            (els.fullStatus.style.color =
              latestData.fillStatus === "full" || latestData.isFull
                ? "#dc3545"
                : latestData.fillStatus === "partial"
                  ? "#fd7e14"
                  : latestData.fillStatus === "empty"
                    ? "#28a745"
                    : "#6c757d"),
            (els.lastUpdateSmall.textContent = `Last update: ${
              latestData.serverTimestamp
                ? new Date(latestData.serverTimestamp).toLocaleTimeString()
                : "--"
            } (Historical)`),
            (els.statusText.textContent = `Showing latest data from ${deviceId} (Offline)`));
        } catch (e) {
          console.error("loadHistoricalDataForDevice", e);
          setNoData();
        }
      }
      async function updateCharts() {
        try {
          if (!selectedDevice) {
            const dd = await (await fetch("/api/device-data")).json();
            const ids = Object.keys(dd);
            if (!ids.length) {
              try {
                const devicesResponse = await fetch("/api/devices");
                const devicesData = await devicesResponse.json();
                const historicalIds = devicesData.deviceIds || [];
                if (!historicalIds.length) return;
                selectedDevice = historicalIds[0];
              } catch (err) {
                console.warn(
                  "Could not load historical devices for charts",
                  err,
                );
                return;
              }
            } else {
              selectedDevice = ids[0];
            }
          }
          const res = await fetch(
            `/api/history?deviceId=${encodeURIComponent(
              selectedDevice,
            )}&limit=100`,
          );
          const h = await res.json();
          if (!h || !h.timestamps) return;

          const labels = h.timestamps.map((t) =>
            new Date(t).toLocaleTimeString(),
          );
          const dist = h.distance || [];
          const servo = h.servo || [];
          const motion = h.motion || [];

          if (!distanceChart) {
            distanceChart = new Chart(distanceCtx, {
              type: "line",
              data: {
                labels,
                datasets: [
                  {
                    label: "Distance (cm)",
                    data: dist,
                    borderColor: "#2563eb",
                    tension: 0.2,
                    pointRadius: 0,
                  },
                ],
              },
              options: {
                animation: false,
                responsive: true,
                scales: { y: { title: { display: true, text: "cm" } } },
                plugins: { legend: { display: false } },
              },
            });
          } else {
            distanceChart.data.labels = labels;
            distanceChart.data.datasets[0].data = dist;
            distanceChart.update("none");
          }

          if (!servoChart) {
            servoChart = new Chart(servoCtx, {
              type: "line",
              data: {
                labels,
                datasets: [
                  {
                    label: "Servo (°)",
                    data: servo,
                    borderColor: "#dc2626",
                    tension: 0.2,
                    pointRadius: 0,
                  },
                ],
              },
              options: {
                animation: false,
                responsive: true,
                scales: { y: { title: { display: true, text: "degrees" } } },
                plugins: { legend: { display: false } },
              },
            });
          } else {
            servoChart.data.labels = labels;
            servoChart.data.datasets[0].data = servo;
            servoChart.update("none");
          }

          if (!motionChart) {
            motionChart = new Chart(motionCtx, {
              type: "line",
              data: {
                labels,
                datasets: [
                  {
                    label: "Motion",
                    data: motion,
                    borderColor: "#16a34a",
                    stepped: true,
                    pointRadius: 0,
                  },
                ],
              },
              options: {
                animation: false,
                responsive: true,
                scales: { y: { min: 0, max: 1 } },
                plugins: { legend: { display: false } },
              },
            });
          } else {
            motionChart.data.labels = labels;
            motionChart.data.datasets[0].data = motion;
            motionChart.update("none");
          }
        } catch (e) {
          console.error("updateCharts", e);
        }
      }
      async function loadThreshold() {
        try {
          const res = await fetch("/api/settings");
          if (!res.ok) return;
          const j = await res.json();
          const t = j.thresholdCm;
          if (typeof t === "number") {
            if (els.thresholdInput) els.thresholdInput.value = String(t);
          }
          const e = j.emptyThresholdCm;
          if (typeof e === "number") {
            if (els.emptyThresholdInput)
              els.emptyThresholdInput.value = String(e);
          }
          const s = j.alertSustainSec;
          if (typeof s === "number" && els.sustainInput) {
            els.sustainInput.value = String(s);
          }
        } catch {}
      }
      function startAutoRefresh() {
        if (document.hidden) return;
        stopAutoRefresh();
        refreshHandle = setInterval(() => {
          updateDashboard();
          updateCharts();
        }, 1500);
      }
      function stopAutoRefresh() {
        if (refreshHandle) {
          clearInterval(refreshHandle);
          refreshHandle = null;
        }
      }
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) stopAutoRefresh();
        else startAutoRefresh();
      });
      window.addEventListener("beforeunload", stopAutoRefresh);
    </script>
  </body>
</html>
